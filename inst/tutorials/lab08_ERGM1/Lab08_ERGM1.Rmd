---
title: "ERGM1"
author: "Claudia Zucca"
date: "10/14/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Welcome to the first of two tutorials about Exponential Random Graph Models (ERGMs).
An ERGM is a statistical tool to assess causality using hypothesis testing 
when the outcome variable is a network. 

This class of models is employed to assess weather the structure of a network 
is random or whether it is originated by some sort of identifiable relational phenomena.


Let's get started with the art of fitting ERGMs!




## Erdos Renyi

After starting soft from logit models and understanding model results, lets 
finally get started with ERGMs. In this section we are going to run one of the 
simplest ERG models that you can possibly think of. 
To do so we are going to use the Florentine marriage network. You are already 
familiar with this graph, so I won't spend more time on discussing it


```{r florentine_load, include = FALSE}

# data(florentine, package='SNA4DS')
# flo_mar <- florentine$flomarriage

florentine <-SNA4DS:::flomar_network

```

Let's just print and check on its class 

```{r viewflo_mar, exercise = TRUE, exercise.setup = "florentine_load"}
florentine
class(florentine)

```
This graph has class network, hence all the `igraph` code we used so far, it's 
not going to work. We have to do things a little differently here.
Take this into account. The output with the network features is different from 
`igraph`, but it's still very simple to read. 

We know that we have 16 nodes and 20 edges, that it's undirected, that it has 
three nodes attributes, and no edge ones.

Let's also plot it, just to check
```{r plotflo_mar, exercise = TRUE, exercise.setup = "florentine_load"}
plot(florentine)
```

Not let's check at the network density in an alternative way:

```{r densityflo_mar, exercise = TRUE, exercise.setup = "florentine_load"}

summary(florentine ~ edges)

```
yes, they are still 20 out of 16*15 possible edges. 

Ok, let's estimate an ERG model! How? with the `ergm` package from the `statnet`
suite! We are going to use mainly one function. Guess what? `ergm`!

```{r ergmflo_mar, exercise = TRUE, exercise.setup = "florentine_load"}

flomodel.01 <- ergm::ergm(florentine ~ edges)  
(s1 <- summary(flomodel.01))

exp(s1$coefficients[1])/ (1 + exp(s1$coefficients[1])) # prob of edges
```
Here we go. The first part of the output is about the model fit. The second part is
the model summary. The last row is the probability 
Congrats! You run your first ERGM. 

Edges, is a structural term. We are just checking on the probability that 
those 20 edges are not by chance. Could they have been between any family? In 
other words: Do they marry in a random way?
Usually people marry for a reason. Love or some other, but it's unlikely that 
they marry in a random way.
How about this old Florentine folks? Well, according to the model results, they 
did not marry by chance too. P-value is < 0.0001, hence there is a high 
probability that we can reject the null hypothesis of marrying by chance. 
What about the coefficient? The fact that it is negative means that the network 
is sparse. The probability of these edges is 16%. These old Florentine dudes, 
do not marry by chance, and do not marry that easily either. These weddings are 
well thought, and kind of exclusive. It's not for every family to marry there! 

### Simulation

We said that we are checking on the probability that our observed network is 
different from some random others that are built using the same parameters 
but have no effects (null distribution). This means that we are comparing our 
observed Florentine network with many others simulated ones with the same 
parameters: Nodes and Edges. 

In Network Science, a random network with fixed number of nodes and edges is an 
Erdos Renyi one. Let'try

```{r erdos_renyi, exercise = TRUE}
plot(igraph::erdos.renyi.game(16, 20, type = 'gnm'))

```
This network we just plotted is really similar to the Florentine one, but still 
not quite the same. Generating a 1000 of these using this the 
`igraph::erdos.renyi.game` function, we could manually test our null 
hypothesis of no effects . 

Many other times, we have to compare our observed network with no standard 
structures. To do so, in the future, we can simply use the function `simulate`.

```{r simulate_flo, exercise = TRUE, exercise.setup = "florentine_load"}
flomodel.01 <- ergm::ergm(florentine ~ edges)
simflo <- simulate(flomodel.01, burnin = 1e+6, verbose = TRUE, seed = 9)
plot(simflo)
```
In this case, we have full control on the parameters, since we are explicitly 
asking the function to simulate something that has exactly the same terms as
our `flomodel.01`.

Enough with this easy toy model! we are ready for something juicier!

## P1

The ER ERGM is cute, but it explain reality to a very small extent. In this
section we will take a look at the P1 that is considered ERGM's grandfather.
In fact ERGMs are allo called P* as a better version of the P1 model.

```{r sampson_load, include = FALSE}
sampson <- SNA4DS:::samplike
```

While the ER model can be applied to undirected networks since it only considers
whether there are ties or not (not checking on what kind of ties), the P1 checks 
on the kind of ties and for this reason it was designed for a directed network. We are
going to use now the Sampson data that you are also already familiar with. 

I'm just going to remind you that it is an ethnographic study of a New England 
monastery's community structure by Samuel F. Sampson.
Social relationships among a group of men (novices) who were preparing to join a 
monastic order.

Let's quickly explore it. 

```{r plotSampson, exercise = TRUE, exercise.setup = "sampson_load"}
sampson 
plot(sampson)

```
This is a subset of the Sampson data that only considers whether the monks like 
each other (directional edge) or not (no edge). We know it's 18 nodes and 88 
edges directed network with no loops and two attributes loaded in the network format.

The P1 model checks on the probability that the observed network is not random, 
but that it's the outcome of some social dynamic focusing on: 

* edges formation (as the ER), 
* sender of the tie, 
* receiver of the ties 
* and the mutuality between sender and receiver.

We are going to use three new ERGM structural terms:

* `sender` 
* `receiver`
* `mutual`

Let's specify our model and print the results! This might take your computer
a few seconds to process, so be patient.

```{r p1Sampson, exercise = TRUE, exercise.setup = "sampson_load"}
P1 <- ergm::ergm(sampson ~ edges + sender + receiver + mutual)

texreg::screenreg(P1, ci.force = TRUE)
```

Waw, what's this output? It's really long! Well, some terms that you specify in 
the ERG models estimate one statistic summarizing the all situation in your 
network. `edges` and `mutual` do so in this case. Some other terms such as 
`sender` and `receiver` compute a statistic for each single node in the network. 
That's why this output is so insanely long. When you choose the terms for your model
take this into account because commenting on each single node in a network with 
200 of them is no fun. 

`sender` and `receiver` look at the probability that each 
single connection is not random: an expression of likelihood between 2 and 5 is completely 
different from one between 5 and 2, as much as one between 12 and 18. This kind 
of approach is perfect for an ethnographic study like this that aims at understanding
specific social dynamics in a small community. It would be not very helpful for 
explaining the behavior in an Twitter network. 

Note that not every node is in the output of the model though. Node number one 
is missing. This is not a mistake. Removing one node is necessary to avoid a 
linear dependency between all the others. Node one constitutes the reference 
category and every other result has to be compared to node one.

For instance, node 10 has a significant sender effect with a probability of the 
89% that his behavior of liking other monks is not by chance. But this value 
makes sense only if compared to the behavior of node one. Monk ten is 89% more likely 
than monk one of liking other monks. That's all we can claim. Changing the 
reference category our results might be slightly different since it changes our
perspective, our point of observation, on this community of monks. However, if 
we assume that these monks share some similarities since they are part of the 
same community, changing the reference category should not drastically modify 
our claims on the non randomness of these ties.

We can also simulate random networks that share the same parameters as the 
Sampson p1 model

```{r simp1Sampson, exercise = TRUE, exercise.setup = "sampson_load"}

P1 <- ergm::ergm(sampson ~ edges + sender + receiver + mutual)

simSam <- simulate(P1, burnin = 1e+6, verbose = TRUE, seed = 9)
plot(simSam)
```
Here we go, it looks very similar indeed, but this is random, while the relationships 
in the original one are socially driven. Isn't it fascinating?


ER and P1 consider only structural effects. When we run them we don't take any 
attribute into consideration. But is not longer going to be the case from the 
next section and afterwards since explaining social reality requires way more 
sophistication that this :) 


## P* or ERGM

You don't have the hard g in Dutch, so it's hard: pronunciation "eurcoom" "eurghum"

Exoenous and endogenous effects 

Sim City.



## Dyadic Independent Terms

An ERG model is all about finding the best 'dress' to fit our data.

The terms we employed so far only look at independent effects since the probability
of observing them does not depend on the existence of other ties, but only on 
properties of the individual nodes. But, even still focusing only on the effects 
that do not involve edge dependencies, there are many more options. We need to 
explore more ERGM terms. If you type in your `RStudio` console `search.ergmTerms`,
it will appear to you the help file. Now we focus on the dyadic independent terms
only, that you can print out using the following line of code:


```{r dyad-indepTerms, exercise = TRUE}
ergm::search.ergmTerms(categories = 'dyad-independent')
```

There are 60 terms that correspond to this description! Let's experiment 
one of the most popular: `nodecov`.

```{r nodecov-search, exercise = TRUE}
ergm::search.ergmTerms(name = 'nodecov')
```
The line of code above prints out all you need to know about `nodecov`. 
Let's test it with the Florentine marriage network and one of its attributes, 
wealth. Let's also assume that we are nesting models to explore our network 
further. Hence, we build on `flomodel.01`.

```{r nodecovModel, exercise = TRUE, exercise.setup = "florentine_load"}
flomodel.01 <- ergm::ergm(florentine ~ edges)  

flomodel.02 <- ergm::ergm(florentine ~ edges + nodecov("Wealth"))   

texreg::screenreg(list(flomodel.01, flomodel.02), ci.force = TRUE)
```
In this case it is helpful to look at the goodness of fit for model comparison
According to 
* AIC Model two is better.  
* BIC Model one and two are roughly the same, with model two a tiny bit better
* Log Likelihood claims that Model one is better

We will need the GOF that are specific for ERG models to establish which model 
is better representing the social dynamics in the Florentine marriage data set.
For now, we can comment on the `nodecov` term's result and say that there is a high 
probability that we can reject the null hypothesis and that there is a 50% 
probability that wealth is a determinant of marriages in this network.

We can also simulate flomodel.02.

```{r simulate_nodecov, exercise = TRUE, exercise.setup = "florentine_load"}
flomodel.02 <- ergm::ergm(florentine ~ edges + nodecov("Wealth"))  

simNodecov <- simulate(flomodel.02, burnin = 1e+6, verbose = TRUE, seed = 9)
plot(simNodecov)
```
This simulation represent out base line random model. Our Null hypothesis. 


When we use `nodecov` we are computing the correlation of a vector that expresses
the amount of liras that each family owns, and the edge list of the network. 

There are other ways, still in the dyadic independent universe, to check on the 
possibility that wealth influences marriages in the old Florence. 
One term that can help us doing that is `absdiff`

```{r absdiffSearch, exercise = TRUE}
ergm::search.ergmTerms(name = 'absdiff')
```
This term computes the mixingmatrix that calculate the absolute difference
between the amount of money each family owes. Rather than checking whether being 
rich influences the probability of a marriage in old Florence, we check in the 
probability of being equally rich (or equally non-rich). Let's also nest this
models, shouldn't we? 

```{r absdiffModel, exercise = TRUE, exercise.setup = "florentine_load"}
flomodel.01 <- ergm::ergm(florentine ~ edges)  

flomodel.02 <- ergm::ergm(florentine ~ edges + nodecov("Wealth"))   

flomodel.03 <- ergm::ergm(florentine ~ edges + absdiff("Wealth")) 

flomodel.04 <- ergm::ergm(florentine ~ edges + nodecov("Wealth") + absdiff("Wealth"))   

texreg::screenreg(list(flomodel.01, flomodel.02, flomodel.03, flomodel.04), ci.force = TRUE)
```
Ok, now we are starting to have something cooler to look at. 

Even if in model two and three our terms are significant, when we put them 
together they are not anymore. This could be because we are trying to estimate 
two effects that are too similar and they interfere with each other. Remember, 
one is estimating a vector and the other a matrix, but the substantive meaning 
is not that different. In general we know that model 4 is not a good fit to our 
network. We are going in the wrong direction and when this happens you simply 
discard that option and test others. 

Anyway, model three shows us that we can reject the null and that the probability 
that being equally rich influences marriages is also around 50%. 


## Reading results 

copy from the slides/tutorial on logit. the three condition statements, breafly the odds ratios 


## Conclusion

This is enough for this tutorial! In the next one we are going to cover 
dyadic dependence and goodness of fit. I very much hope that you are looking 
forward! See you at ERGM 2!
